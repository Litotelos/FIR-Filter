;**********************************************************************
;                                                                     *
;    FIR Filter - Coursework1 Filter 7 - Extended Solution           *
;    Implements interrupt-driven ADC sampling with GPIO output       *
;    Author:                                                          *
;    Date:                                                            *
;                                                                     * 
;**********************************************************************

	list		p=16f877A	
	#include	<p16f877A.inc>	
	
    __CONFIG _CP_OFF & _WDT_OFF & _BODEN_OFF & _PWRTE_ON & _RC_OSC & _WRT_OFF & _LVP_ON & _CPD_OFF

    
;**************************************************************************
; MACROS							  
;**************************************************************************
;Shift a 16 bit value left (x2)
SHIFT_LEFT_16   MACRO   lower_byte, upper_byte
    bcf	STATUS,C
    rlf	lower_byte,f
    rlf	upper_byte,f
    ENDM
    
;Shift a 16 bit value right (/2)
SHIFT_RIGHT_16  MACRO   lower_byte, upper_byte
    bcf	STATUS,C
    rrf	upper_byte,f
    rrf	lower_byte,f
    ENDM
    
;Add 16 bit temporary values to accumulator
ADD_ACCUM   MACRO	
    movf	temp_lower,w
    Addwf	accum_lower,f
    btfsc	STATUS,C
    incf	accum_upper,f
    movf	temp_upper,w
    Addwf	accum_upper,f
    ENDM
    
;Negate a 16-bit signed value
TWOS_COMPLEMENT_16  MACRO   lower_byte, upper_byte
    comf	lower_byte,f
    comf	upper_byte,f
    movlw	0x01
    addwf	lower_byte,f
    btfsc	STATUS,C
    incf	upper_byte,f
    ENDM
	
;Unscaling from Q2 format
UNSCALE_Q2  MACRO   lower_byte, upper_byte
    SHIFT_RIGHT_16	lower_byte, upper_byte
    SHIFT_RIGHT_16	lower_byte, upper_byte
    ENDM
    
;Clear 16 bit register pair
CLEAR_16 MACRO  lower_byte, upper_byte
    clrf	lower_byte
    clrf	upper_byte
    ENDM
		    

;**************************************************************************
; Variable definations							  
;**************************************************************************

;Input Sample
x_k		EQU	0x20		
x_k_lower	EQU	0x21
x_k_upper	EQU	0x22

;Delayed Samples (FIR filter delay line)
x_k1_lower	EQU	0x23
x_k1_upper	EQU	0x24
x_k2_lower	EQU	0x25
x_k2_upper	EQU	0x26
x_k3_lower	EQU	0x27
x_k3_upper	EQU	0x28
x_k4_lower	EQU	0x29
x_k4_upper	EQU	0x2A
x_k5_lower	EQU	0x2B
x_k5_upper	EQU	0x2C
x_k6_lower	EQU	0x2D
x_k6_upper	EQU	0x2E
x_k7_lower	EQU	0x2F
x_k7_upper	EQU	0x30
	
;Temporary Working Registers
temp_lower	EQU	0x31
temp_upper	EQU	0x32
temp2_lower	EQU	0x33
temp2_upper	EQU	0x34

;Accumulator
accum_lower	EQU	0x35
accum_upper	EQU	0x36		
	
;Output
y_k		EQU	0x37

;Flag to indicate new ADC sample is ready
new_sample_ready	EQU	0x38
	
;Context Saving Variables for ISR
w_temp		EQU	0x7D	; variable used for context saving
status_temp	EQU	0x7E	; variable used for context saving
pclath_temp	EQU	0x7F	; variable used for context saving

;****************************************************************************
	ORG     0x000			; processor reset vector
	nop				; nop required for icd
  	goto    main			; go to beginning of program


	ORG     0x004			; Interrupt vector  location

	; Save context
	movwf   w_temp			; save off current W register contents
	movf	STATUS,w		; move status register into W register
	movwf	status_temp		; save off contents of STATUS register
	movf	PCLATH,w		; move pclath register into w register
	movwf	pclath_temp		; save off contents of PCLATH register

; Interrupt Service Routine Triggered by Timer0 overflow at 2kHz
; Acquires ADC sample and sets flag for main loop processing

	; Read 8-bit ADC result from ADRESH (Bank 1)
	bsf     STATUS, RP0
	movf    ADRESH, w
	bcf     STATUS, RP0
	movwf   x_k			; Store ADC sample

	; Set flag to notify main loop new sample is ready
	bsf     new_sample_ready, 0

	; Start next ADC conversion
	bsf     ADCON0, GO

	
	movlw   .6	; Reload Timer0 for consistent 2kHz sampling rate
	movwf   TMR0

	bcf     INTCON, T0IF ;Clear Timer0 interrupt flag

	; Restore context
	movf	pclath_temp,w
	movwf	PCLATH
	movf    status_temp,w
	movwf	STATUS
	swapf   w_temp,f
	swapf   w_temp,w
	retfie
;****************************************************************************

main
	; Configure PORTB as output for filter result
	bsf     STATUS, RP0		;Switch to Bank 1
	clrf    TRISB			;All PORTB pins as outputs
	bcf     STATUS, RP0		;Back to Bank 0
	clrf    PORTB			;Clear PORTB
	
	; Configure ADC: AN0 as analog input, right-justified result
	bsf     STATUS, RP0
	movlw   b'10001110'		; Right justified, AN0 analog
	movwf   ADCON1
	bcf     STATUS, RP0
	
	movlw   b'01000001'		; Fosc/8 clock, AN0 selected, ADC enabled
	movwf   ADCON0
	
	; Configure Timer0 for 2kHz interrupt rate
	; With 4MHz oscillator: 1MHz instruction rate
	; Prescaler 1:2, preload 6 gives 500us = 2kHz
	bsf     STATUS, RP0
	movlw   b'00000000'		; Internal clock, prescaler 1:2
	movwf   OPTION_REG
	bcf     STATUS, RP0
	
	movlw   .6			; Preload value for 2kHz
	movwf   TMR0
	bsf     INTCON, T0IE		; Enable Timer0 interrupt
	bsf     INTCON, GIE		; Enable global interrupts
	
	; Start first ADC conversion
	bsf     ADCON0, GO
	
	; Initialize all filter registers to zero
	clrf	x_k
	CLEAR_16    x_k_lower, x_k_upper
	CLEAR_16    x_k1_lower, x_k1_upper
	CLEAR_16    x_k2_lower, x_k2_upper
	CLEAR_16    x_k3_lower, x_k3_upper
	CLEAR_16    x_k4_lower, x_k4_upper
	CLEAR_16    x_k5_lower, x_k5_upper
	CLEAR_16    x_k6_lower, x_k6_upper
	CLEAR_16    x_k7_lower, x_k7_upper
	CLEAR_16    accum_lower, accum_upper
	clrf	y_k
	clrf	new_sample_ready
	
Sample_loop	
	; Wait for new ADC sample from ISR
	btfss	new_sample_ready, 0 ; Wait for new ADC sample from ISR
	goto	Sample_loop
	
	bcf	new_sample_ready, 0 ; Clear flag - processing this sample
	
	;Process Input
	call	PROCESS_INPUT
	call	SCALE_INPUT
	
	CLEAR_16    accum_lower, accum_upper ; Clear Accumulator
	
	; Run all the MAC operations
	call	TAP_1			
	call	TAP_2			
	call	TAP_3			
	call	TAP_4			
	call	TAP_5			
	call	TAP_6			
	call	TAP_7		
	
	; Unscale result
	UNSCALE_Q2  accum_lower, accum_upper
	
	; Store result into y_k
	movf	accum_lower,w
	movwf	y_k
	
	; Output result to PORTB
	movf	y_k,w
	movwf	PORTB
	
	; Update delay line
	call	UPDATE_DELAY_LINE
		
	goto	Sample_loop		; Wait for next sample

;**************************************************************************
; Subroutines								  
;**************************************************************************

;Processing input - Sign extension and Scaling
PROCESS_INPUT
	movf	x_k,0			;Loading the 8 bit value to W register
	movwf	x_k_lower		;Store into lower byte of 16 bit value
	
	btfsc	x_k_lower,7		;Check MSB (bit 7) - skip if bit 7 is 0
	goto	NEGATIVE_INPUT		;Bit 7 is 1
	goto	POSITIVE_INPUT		;Bit 7 is 0
NEGATIVE_INPUT
	movlw	0xFF			; ;Load 0xFF
	movwf	x_k_upper		;Upper byte for negative numbers set as 0XFF
	return
POSITIVE_INPUT
	clrf	x_k_upper		;Clear Upper byte for positive numbers
	return

;Scaled from Q0 to Q2 (x4) - two fractional bits
SCALE_INPUT
	SHIFT_LEFT_16  x_k_lower, x_k_upper	; x2
	SHIFT_LEFT_16  x_k_lower, x_k_upper	; x2 again = x4
	return

;Arithmic Overflow check
OVERFLOW
	BTFSS	accum_upper,7			;Test bit 7
	goto	POSITIVE			;If clear the value is positive
NEGATIVE
	BTFSS	accum_upper,6			;Test bit 6
	goto	NEG_OVERFLOW_SAT		;If clear negative overflow ocurred
	return
POSITIVE
	BTFSC	accum_upper,6			;Test bit 6
	goto	POS_OVERFLOW_SAT		;If set positive overflow ocurred
	return
NEG_OVERFLOW_SAT
	movlw	0X80				;Upper byte -32768 : (1000 0000)
	movwf	accum_upper
	movlw	0x00				;Lower byte -32768 : (0000 0000)
	movwf	accum_lower
	return
POS_OVERFLOW_SAT
	movlw	0x7F				;Upper byte +32767 : (0111 1111)
	movwf	accum_upper
	movlw	0xFF				;Lower byte +32767 : (1111 1111)
	movwf	accum_lower
	return

;Shifting each sample down the delay line
UPDATE_DELAY_LINE 
	movf	x_k6_lower,w
	movwf	x_k7_lower
	movf	x_k6_upper,w
	movwf	x_k7_upper
 
	movf	x_k5_lower,w
	movwf	x_k6_lower
	movf	x_k5_upper,w
	movwf	x_k6_upper
    
	movf	x_k4_lower,w
	movwf	x_k5_lower
	movf	x_k4_upper,w
	movwf	x_k5_upper
	
	movf	x_k3_lower,w
	movwf	x_k4_lower
	movf	x_k3_upper,w
	movwf	x_k4_upper
	
	movf	x_k2_lower,w
	movwf	x_k3_lower
	movf	x_k2_upper,w
	movwf	x_k3_upper
	
	movf	x_k1_lower,w
	movwf	x_k2_lower
	movf	x_k1_upper,w
	movwf	x_k2_upper
	
	movf	x_k_lower,w
	movwf	x_k1_lower
	movf	x_k_upper,w
	movwf	x_k1_upper
	return
	

TAP_1	
	;Multiply: x (k-1) * 0.5 (Q2 scaled is x2)
	movf	x_k1_lower,w			;Load Lower byte of x(k-1)
	movwf	temp_lower			;Store in temp_lower
	movf	x_k1_upper,w			;Load Upper byte of x(k-1)
	movwf	temp_upper			;Store in temp_upper
	
	;Multiply x2
	SHIFT_LEFT_16  temp_lower, temp_upper
	
	;Add x(k-1) Accumulator
	ADD_ACCUM
	
	;Check Arithmetic overflow after accumulation
	call	OVERFLOW	   			  
	return
	
	
TAP_2
	;Multiply: x(k-2) * 1.5 (Q2 scaled is x6)
	movf	x_k2_lower,w			;Load lower byte of x(k-2)
	movwf	temp_lower			;Store in temp_lower
	movf	x_k2_upper,w			;Load upper byte of x(k-2)
	movwf	temp_upper			;Store in temp_upper
	
	movf	x_k2_lower,w			;Load lower byte of x(k-2)
	movwf	temp2_lower			;Store in temp2_lower
	movf	x_k2_upper,w			;Load upper byte of x(k-2)
	movwf	temp2_upper			;Store in temp2_upper
	
	;Multiply x4
	SHIFT_LEFT_16  temp_lower, temp_upper	;Shift 1 (x2)
	SHIFT_LEFT_16  temp_lower, temp_upper	;Shift 2 (x2)
	
	;Multiply x2
	SHIFT_LEFT_16  temp2_lower, temp2_upper	;Shift 1 (x2)
	
	;Addition of x4 and x2 values for x6
	bcf	STATUS, C			;Clear Carry Flag
	movf	temp2_lower,w			;Load x2 value lower byte
	addwf	temp_lower,f			;Add  x2 and x4 lower byte values
	btfsc	STATUS,C			;If carry flag set, increment upper byte
	incf	temp_upper,f
	
	movf	temp2_upper,w			;Load x2 value upper byte
	addwf	temp_upper,f			;Add x2 and x4 upper byte values
	
	;Add x(k-2) Accumulator
	ADD_ACCUM
	
	;Check Arithmetic overflow after accumulation
	call	OVERFLOW	   			  
	return
	
TAP_3
	;Multiply: x(k-3) * 4 (Q2 scaled is x16)
	movf	x_k3_lower,w			 ;Load Lower byte of x(k-3)
	movwf	temp_lower			 ;Store in temp_lower
	movf	x_k3_upper,w			 ;Load Upper byte of x(k-3)
	movwf	temp_upper			 ;Store in temp_upper
	
	;Multiply x16
	SHIFT_LEFT_16  temp_lower, temp_upper	 ;Shift 1 (x2)
	SHIFT_LEFT_16  temp_lower, temp_upper	 ;Shift 2 (x2)
	SHIFT_LEFT_16  temp_lower, temp_upper	 ;Shift 3 (x2)
	SHIFT_LEFT_16  temp_lower, temp_upper	 ;Shift 4 (x2) 
	
	;Add x(k-3) Accumulator
	ADD_ACCUM
	
	;Check Arithmetic overflow after accumulation
	call	OVERFLOW	   			  
	return
	
	
TAP_4
	;Multiply: x(k-4) * 4 (Q2 scaled is x16)
	movf	x_k4_lower,w			;Load Lower byte of x(k-4)
	movwf	temp_lower			;Store in temp_lower
	movf	x_k4_upper,w			;Load Upper byte of x(k-4)
	movwf	temp_upper			;Store in temp_upper
	
	;Multiply x16
	SHIFT_LEFT_16  temp_lower, temp_upper	;Shift 1 (x2)
	SHIFT_LEFT_16  temp_lower, temp_upper	;Shift 2 (x2)
	SHIFT_LEFT_16  temp_lower, temp_upper	;Shift 3 (x2)
	SHIFT_LEFT_16  temp_lower, temp_upper	;Shift 4 (x2)
	
	;Add x(k-4) Accumulator
	ADD_ACCUM
	
	;Check Arithmetic overflow after accumulation
	call	OVERFLOW	   			  
	return
	
	
TAP_5
	;Multiply: x(k-5) * 1.5 (Q2 scaled is x6)
	movf	x_k5_lower,w			;Load lower byte of x(k-5)
	movwf	temp_lower			;Store in temp_lower
	movf	x_k5_upper,w	   		;Load upper byte of x(k-5)
	movwf	temp_upper			;Store in temp_upper

	movf	x_k5_lower,w			;Load lower byte of x(k-5)
	movwf	temp2_lower			;Store in temp2_lower
	movf	x_k5_upper,w	   		;Load upper byte of x(k-5)
	movwf	temp2_upper			;Store in temp2_upper
	
	;Multiply x4
	SHIFT_LEFT_16  temp_lower, temp_upper	;Shift 1 (x2)
	SHIFT_LEFT_16  temp_lower, temp_upper	;Shift 2 (x2)
	
	;Multiply x2
	SHIFT_LEFT_16  temp2_lower, temp2_upper	;Shift 1 (x2)
	
	;Addition of x4 and x2 values for x6
	bcf	STATUS, C			;Clear Carry Flag
	movf	temp2_lower,w			;Load x2 value lower byte
	addwf	temp_lower,f			;Add  x2 and x4 lower byte values
	btfsc	STATUS,C			;If carry flag set, increment upper byte
	incf	temp_upper,f
	
	movf	temp2_upper,w			;Load x2 value upper byte
	addwf	temp_upper,f			;Add x2 and x4 upper byte values
	
	;Add x(k-5) Accumulator
	ADD_ACCUM
	
	;Check Arithmetic overflow after accumulation
	call	OVERFLOW	   			  
	return
	

TAP_6
	;Multiply: x(k-6) * 2 (Q2 scaled is x8)
	movf	x_k6_lower,w			;Load Lower byte of x(k-6)
	movwf	temp_lower			;Store in temp_lower
	movf	x_k6_upper,w			;Load Upper byte of x(k-6)
	movwf	temp_upper			;Store in temp_upper
	
	;Multiply x8
	SHIFT_LEFT_16  temp_lower, temp_upper	;Shift 1 (x2)
	SHIFT_LEFT_16  temp_lower, temp_upper	;Shift 2 (x2)
	SHIFT_LEFT_16  temp_lower, temp_upper	;Shift 3 (x2)
	
	;Add x(k-6) Accumulator
	ADD_ACCUM
	
	;Check Arithmetic overflow after accumulation
	call	OVERFLOW	   			  
	return
	
	
TAP_7
	;Multiply: x(k-7) * (-0.25) (Q2 scaled is x-1)
	movf	x_k7_lower,w			;Load Lower byte of x(k-7)
	movwf	temp_lower			;Store in temp_lower
	movf	x_k7_upper,w			;Load Upper byte of x(k-7)
	movwf	temp_upper			;Store in temp_upper
	
	;Twos Complement of x(k-7)
	TWOS_COMPLEMENT_16  temp_lower, temp_upper			
	
	;Add -x(k-7) Accumulator
	ADD_ACCUM
	
	;Check Arithmetic overflow after accumulation
	call	OVERFLOW	   			  
	return
END
